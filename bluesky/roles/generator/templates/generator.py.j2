#!/usr/bin/env python3

import requests
import time
import socket
import json
import sys
import random
from textblob import TextBlob
from collections import deque

USERNAME = "{{ bluesky_username }}"
APP_PASSWORD = "{{ bluesky_app_password }}"
QUERY = "{{ query_term }}"
POLL_INTERVAL = 30
BASE_URL = "https://bsky.social/xrpc"
LOGSTASH_HOSTS = [{% for host in groups['logstash'] %}"{{ host }}"{% if not loop.last %}, {% endif %}{% endfor %}]
LOGSTASH_PORT = 5001
BUFFER_FILE = "/usr/local/bin/pendientes.jsonl"
logstash_up = True
MAX_RETRIES = 5
consecutive_errors = 0

def exit_if_max():
    global consecutive_errors
    if consecutive_errors >= MAX_RETRIES:
        print("Too many consecutive errors, exiting.")
        sys.exit(1)

def load_pending():
    try:
        with open(BUFFER_FILE, "r") as f:
            return [json.loads(line) for line in f]
    except Exception as e:
        print("Error while reading pending logs:", e)
        return []

def save_pending(data):
    with open(BUFFER_FILE, "a") as f:
        f.write(json.dumps(data) + "\n")

def clear_pending():
    try:
        open(BUFFER_FILE, "w").close()
    except:
        pass

def send_log(log, hosts, retries=True):
    attempts = MAX_RETRIES if retries else 1
    for _ in range(attempts):
        for host in hosts:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((host, LOGSTASH_PORT))
                sock.send((json.dumps(log) + "\n").encode())
                sock.close()
                return True
            except:
                time.sleep(0.5)
    return False

def send_pending(hosts):
    pending = load_pending()
    if not pending:
        return

    remaining = []
    for log in pending:
        if not send_log(log, hosts):
            remaining.append(log)

    if remaining:
        with open(BUFFER_FILE, "w") as f:
            for r in remaining:
                f.write(json.dumps(r) + "\n")
    else:
        clear_pending()

def send_to_logstash(data):
    global logstash_up
    hosts = LOGSTASH_HOSTS[:]
    random.shuffle(hosts)
    success = send_log(data, hosts, retries=logstash_up)
    logstash_up = success

    if not success:
        print("Error sending log, storing as pending")
        save_pending(data)
        return

    send_pending(hosts)

def login():
    print("Logging into Bluesky...")
    resp = requests.post(
        f"{BASE_URL}/com.atproto.server.createSession",
        json={"identifier": USERNAME, "password": APP_PASSWORD},
        timeout=15
    )
    resp.raise_for_status()
    data = resp.json()
    print("Session established.")
    return data["accessJwt"]

def search_posts(token, query, limit=50):
    params = {"q": query, "limit": limit, "lang": "en"}
    headers = {"Authorization": f"Bearer {token}"}
    resp = requests.get(
        f"{BASE_URL}/app.bsky.feed.searchPosts",
        headers=headers,
        params=params,
        timeout=20
    )
    resp.raise_for_status()
    return resp.json()

def main():
    global consecutive_errors
    processed = deque(maxlen=200)

    try:
        token = login()
        consecutive_errors = 0
    except Exception as e:
        print("Login error, exiting:", e)
        exit_if_max()

    while True:
        try:
            data = search_posts(token, QUERY, limit=100)
            consecutive_errors = 0

        except requests.exceptions.HTTPError as e:
            if e.response is not None and e.response.status_code == 401:
                print("Token expired. Re-authenticating...")
                time.sleep(3)
                try:
                    token = login()
                    consecutive_errors = 0
                    continue
                except Exception as login_e:
                    print("Re-authentication failed:", login_e)
                    consecutive_errors += 1
                    exit_if_max()
                continue
            else:
                print("Unexpected HTTP error:", e)
                consecutive_errors += 1
                exit_if_max()
                time.sleep(10)
                continue

        except Exception as e:
            print("Unexpected error while fetching posts:", e)
            consecutive_errors += 1
            exit_if_max()
            time.sleep(10)
            continue

        posts = data.get("posts", [])

        for p in posts:
            uri = p.get("uri")
            if uri in processed:
                continue

            text = p.get("record", {}).get("text") or ""
            if not text.strip():
                continue

            blob = TextBlob(text)
            sentiment = blob.sentiment.polarity
            subjectivity = blob.sentiment.subjectivity

            log_entry = {
                "author": p.get("author", {}).get("handle"),
                "text": text,
                "sentiment_score": sentiment,
                "subjectivity_score": subjectivity,
                "created": p.get("record", {}).get("createdAt"),
                "uri": uri,
                "query": QUERY
            }

            send_to_logstash(log_entry)
            processed.append(uri)

        time.sleep(POLL_INTERVAL)

if __name__ == "__main__":
    main()
